///Задание: Определен следующий класс (в шаблоне кода):
///Как видно, все поля этого класса закрытые, ваша задача реализовать несколько функций, которые дают полный доступ к этим полям 
///(см. шаблон кода), несмотря на то, что они закрытые.
///Внимание: предполагаемое решение этого задания существенно опирается на Undefined Behaviour и является исключительно учебным, 
///но полезно для лучшего понимания того, как работают модификаторы доступа. 
///Решение было проверено на различных компиляторах (g++/clang++/icc/msvc),  но мы настоятельно не рекомендуем использовать подобные трюки в боевом коде.
///Требования к реализации: при решении этого задания вам разрешается заводить любые вспомогательные функции и классы, 
///но не изменять определение класса Cls. Не нужно вводить или выводить что-либо, также не нужно определять функцию main.
///Источник: Stepic Программирование на языке C++ https://stepik.org/7 от Computer Science Center(CS центр) 
///Глава 3, раздел 5, шаг 7. https://stepik.org/lesson/548/step/7
///Выполнил: Юшаков Н. Р. 24.04.2020.
/*
 * Класс Cls определен точно таким образом:
 *
 * struct Cls {
 * Cls(char c, double d, int i);
 * private:
 *     char c;
 *     double d;
 *     int i;
 * };
 *
 */

// Эта функция должна предоставить доступ к полю c объекта cls.
// Обратите внимание, что возвращается ссылка на char, т. е.
// доступ предоставляется на чтение и запись.
char &get_c(Cls &cls) {
    char *temp = (char*)&cls;
    return *temp;
}

// Эта функция должна предоставить доступ к полю d объекта cls.
// Обратите внимание, что возвращается ссылка на double, т. е.
// доступ предоставляется на чтение и запись.
double &get_d(Cls &cls) {
    double *temp;
    temp = (double*)((char*)(&cls)) + 1;
    return *temp;
}

// Эта функция должна предоставить доступ к полю i объекта cls.
// Обратите внимание, что возвращается ссылка на int, т. е.
// доступ предоставляется на чтение и запись.
int &get_i(Cls &cls) {
    int* ptr;
    ptr = (int*)(((double*)((char*)(&cls)) + 1) + 1);
    return *ptr;
}
